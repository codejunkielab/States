namespace CodeJunkie.StateChart;

using System.Text.Json;
using System.Text.Json.Nodes;
using CodeJunkie.Serialization;
using CodeJunkie.Metadata;

public partial class StateChart<TState> : ICustomSerializable {
  /// <summary>
  /// The JSON property name used to represent the state in serialization.
  /// </summary>
  public const string _stateProperty = "state";

  /// <summary>
  /// The JSON property name used to represent the blackboard in serialization.
  /// </summary>
  public const string _blackboardProperty = "blackboard";

  /// <inheritdoc />
  public object OnDeserialized(IdentifiableTypeMetadata metadata,
                               JsonObject json,
                               JsonSerializerOptions options) {
    var graph = Metadata.Types.Graph;

    var type = GetType();

    var stateJson = json[_stateProperty]?.AsObject() ??
      throw new JsonException(
          $"The state chart with ID '{metadata.Id}' is missing the required '{_stateProperty}' property.");

    var stateId =
      stateJson[Serializer.TYPE_PROPERTY]?.ToString() ??
      throw new JsonException(
        $"The state chart with ID '{metadata.Id}' is missing the state type information.");

    var stateVersion =
      stateJson[Serializer.VERSION_PROPERTY]?.GetValue<int>() ??
      throw new JsonException(
        $"The state chart with ID '{metadata.Id}' is missing the state version information.");

    var blackboardJson =
      json[_blackboardProperty] ?? throw new JsonException(
        $"The state chart with ID '{metadata.Id}' is missing the required '{_blackboardProperty}' property.");

    var blackboard = JsonSerializer.Deserialize<SerializableBlackboard>(blackboardJson, options)!;

    // Instead of replacing the existing blackboard, overwrite its values with
    // those found in the deserialized blackboard. This approach ensures that
    // new persisted or non-persisted values added during construction are preserved.
    foreach (var objType in blackboard.Types) {
      Blackboard.OverwriteObject(objType, blackboard.GetObject(objType));
    }

    if (graph.GetIdentifiableType(stateId) is not { } stateType ||
        graph.GetMetadata(stateType) is not IIdentifiableTypeMetadata) {
      throw new JsonException(
        $"The state chart with ID '{metadata.Id}' has an unknown identifiable state type ID '{stateId}'.");
    }

    var state = Blackboard.GetObject(stateType);

    RestoreState(state);

    return this;
  }

  /// <inheritdoc />
  public void OnSerialized(IdentifiableTypeMetadata metadata,
                           JsonObject json,
                           JsonSerializerOptions options) {
    var graph = Metadata.Types.Graph;

    var stateJson = new JsonObject();

    var stateType = Value.GetType();

    var stateMetadata = (IdentifiableTypeMetadata)graph.GetMetadata(stateType)!;

    stateJson[Serializer.TYPE_PROPERTY] = stateMetadata.Id;
    stateJson[Serializer.VERSION_PROPERTY] = stateMetadata.Version;

    json[_stateProperty] = stateJson;

    json[_blackboardProperty] = JsonSerializer.SerializeToNode(Blackboard, options);
  }
}
