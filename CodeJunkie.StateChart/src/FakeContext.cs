namespace CodeJunkie.StateChart;

using System;
using System.Collections.Generic;
using System.Linq;
using CodeJunkie.Metadata;

/// <summary>
/// Represents a fake context for state charts, designed for testing purposes.
/// Provides mechanisms to manage inputs, outputs, errors, and a blackboard for storing state data.
/// </summary>
public interface IFakeContext : IContext {
  /// <summary>
  /// Retrieves the collection of inputs that have been added to the state chart.
  /// </summary>
  IEnumerable<object> Inputs { get; }

  /// <summary>
  /// Retrieves the collection of outputs that have been generated by the state chart.
  /// </summary>
  IEnumerable<object> Outputs { get; }

  /// <summary>
  /// Retrieves the collection of errors that have been recorded in the state chart.
  /// </summary>
  IEnumerable<Exception> Errors { get; }

  /// <summary>
  /// Stores a mock value in the state chart's blackboard.
  /// </summary>
  /// <param name="value">The value to store in the blackboard.</param>
  /// <typeparam name="TDataType">The type of the value being stored.</typeparam>
  void Set<TDataType>(TDataType value) where TDataType : class;

  /// <summary>
  /// Resets the state chart by clearing the blackboard, inputs, outputs, and errors.
  /// </summary>
  void Reset();
}

/// <summary>
/// A mock state chart context used specifically for testing purposes.
/// </summary>
internal readonly struct FakeContext : IFakeContext {
  private readonly List<object> _inputs = new();
  private readonly List<object> _outputs = new();
  private readonly Dictionary<Type, object> _blackboard = new();
  private readonly List<Exception> _errors = new();

  /// <inheritdoc />
  public IEnumerable<object> Inputs => _inputs.AsEnumerable();
  /// <inheritdoc />
  public IEnumerable<object> Outputs => _outputs.AsEnumerable();
  /// <inheritdoc />
  public IEnumerable<Exception> Errors => _errors.AsEnumerable();

  /// <summary>
  /// Initializes a new instance of the <see cref="FakeContext"/> class.
  /// This constructor is used for creating a mock context for testing purposes.
  /// /// </summary>
  public FakeContext() { }

  /// <summary>
  /// Retrieves a value from the blackboard of the state chart.
  /// </summary>
  public TDataType Get<TDataType>() where TDataType : class {
    var type = typeof(TDataType);
    if (_blackboard.TryGetValue(type, out var value)) {
      return (TDataType)value;
    }

    // If a state is requested and it is a concrete type that can be instantiated,
    // we will create an instance automatically. This approach assumes that states
    // are treated as models during testing and not mocked. This behavior is intended
    // to simplify testing for developers but can be overridden by manually adding
    // the state to the blackboard.
    if (Types.Graph.GetMetadata(type) is IConcreteTypeMetadata concreteMetadata &&
        Types.Graph
        .GetDescendantSubtypes(typeof(StateBase))
        .Contains(type)) {
      var state = concreteMetadata.Factory();
      _blackboard[type] = state;
      return (TDataType)state;
    }

    throw new InvalidOperationException(
        $"The blackboard does not contain a value of type {typeof(TDataType)}. " +
        "Ensure the value is set before attempting to retrieve it.");
  }

  /// <inheritdoc />
  public void Set<TDataType>(TDataType value) where TDataType : class =>
    _blackboard[typeof(TDataType)] = value;

  /// <inheritdoc />
  public void Input<TInputType>(in TInputType input) where TInputType : struct =>
    _inputs.Add(input);

  /// <inheritdoc />
  public void Output<TOutputType>(in TOutputType output) where TOutputType : struct =>
    _outputs.Add(output);

  /// <inheritdoc />
  public void AddError(Exception e) => _errors.Add(e);

  /// <inheritdoc />
  public void Reset() {
    _inputs.Clear();
    _outputs.Clear();
    _errors.Clear();
    _blackboard.Clear();
  }

  /// <inheritdoc />
  public override readonly bool Equals(object? obj) => true;

  /// <inheritdoc />
  public override readonly int GetHashCode() => HashCode.Combine(_inputs, _outputs, _errors);
}
