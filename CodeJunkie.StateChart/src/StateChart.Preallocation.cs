namespace CodeJunkie.StateChart;

using System;
using System.Collections.Generic;
using CodeJunkie.Metadata;

using static Metadata.Types;

public abstract partial class StateChart<TState> {
  /// <summary>
  /// Preallocates instances of all concrete state types in the state hierarchy and adds them to the blackboard.
  /// This process ensures that the states are ready for use during runtime, minimizing heap allocation overhead.
  /// Note: This requires the states to be introspective types with metadata generated by the CodeJunkie.Metadata generator.
  /// </summary>
  /// <param name="logic">
  /// The state chart instance whose states should be preallocated.
  /// </param>
  /// <exception cref="StateChartException">
  /// Thrown if the state chart is missing the required [StateChart] attribute or if any state types are not serializable.
  /// </exception>
  internal static void PreallocateStates(IStateChart<TState> logic) {
    var type = logic.GetType();
    var metadata = Graph.GetMetadata(type);

    if (metadata is not IIntrospectiveTypeMetadata introspectiveMetadata) {
      // No preallocation for non-introspective types.
      return;
    }

    if (Graph.GetAttribute<StateChartAttribute>(type) is not { } logicAttribute) {
      throw new StateChartException(
          $"The state chart `{type}` is missing the required " +
          $"[{nameof(StateChartAttribute)}] attribute. Please ensure the attribute is applied to the state chart class.");
    }

    var isIdentifiable = metadata is IIdentifiableTypeMetadata;

    var baseStateType = logicAttribute.StateType;
    var descendantStateTypes = Graph.GetDescendantSubtypes(baseStateType);

    var stateTypesNeedingAttention =
      isIdentifiable ? new HashSet<Type>(descendantStateTypes.Count + 1) : null;

    void cacheStateIfNeeded(Type type, IConcreteTypeMetadata metadata) {
      if (!ReferenceStates.ContainsKey(type)) {
        ReferenceStates.TryAdd(type, metadata.Factory());
      }
    }

    void discoverState(Type type) {
      if (isIdentifiable) {
        var stateMetadata = Graph.GetMetadata(type);

        if (stateMetadata is IIntrospectiveTypeMetadata iMetadata &&
            iMetadata.Metatype.Attributes.ContainsKey(typeof(TestStateAttribute))) {
          return;
        }

        if (stateMetadata is IIdentifiableTypeMetadata idMetadata) {
          if (idMetadata is IConcreteTypeMetadata concreteMetadata) {
            cacheStateIfNeeded(type, concreteMetadata);

#if WITH_SERIALIZATION
            logic.SaveObject(
              type: type,
              factory: concreteMetadata.Factory,
              referenceValue: ReferenceStates[type]
            );
#endif

            logic.OverwriteObject(type, concreteMetadata.Factory());
          }
        }
        else if (stateMetadata is not IIntrospectiveTypeMetadata) {
          stateTypesNeedingAttention!.Add(type);
        }
        else if (stateMetadata is IConcreteTypeMetadata) {
          stateTypesNeedingAttention!.Add(type);
        }

        return;
      }

      if (Graph.GetMetadata(type) is IConcreteTypeMetadata metadata) {
        cacheStateIfNeeded(type, metadata);
        logic.OverwriteObject(type, metadata.Factory());
      }
    }

    discoverState(baseStateType);

    foreach (var stateType in descendantStateTypes) {
      discoverState(stateType);
    }

    if (!isIdentifiable) { return; }

    if (stateTypesNeedingAttention!.Count == 0) { return; }

    var statesNeedingAttention = string.Join(", ", stateTypesNeedingAttention);

    throw new StateChartException(
        $"The serializable state chart `{type}` contains states that are not serializable. " +
        $"Ensure the following types are annotated with both the " +
        $"[{nameof(MetaAttribute)}] and [{nameof(IdAttribute)}] attributes: " +
        $"{statesNeedingAttention}.");
  }
}
