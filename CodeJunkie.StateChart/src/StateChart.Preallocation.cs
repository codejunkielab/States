namespace CodeJunkie.StateChart;

using System;
using System.Collections.Generic;
using CodeJunkie.Metadata;

using static Metadata.Types;

public abstract partial class StateChart<TState> {
  /// <summary>
  /// Adds an instance of every concrete state type in the state hierarchy to
  /// the blackboard. For this to work, the states and its states must be
  /// introspective types whose introspection metadata is generated by the
  /// CodeJunkie.Metadata generator.
  /// </summary>
  /// <param name="logic">State chart whose states should be preallocated.
  /// </param>
  /// <exception cref="StateChartException" />
  internal static void PreallocateStates(IStateChart<TState> logic) {
    var type = logic.GetType();
    var metadata = Graph.GetMetadata(type);

    if (metadata is not IIntrospectiveTypeMetadata introspectiveMetadata) {
      // No preallocation for non-introspective types.
      return;
    }

    if (
      Graph.GetAttribute<StateChartAttribute>(type) is not { } logicAttribute
    ) {
      // We're missing the states attribute. Introspective types must
      // have the [StateChart] attribute.
      throw new StateChartException(
        $"State chart `{type}` is missing the " +
        $"[{nameof(StateChartAttribute)}] attribute."
      );
    }

    // See if states is an identifiable, introspective type (serializable).
    // If it is, we will throw if any of its states are not also identifiable,
    // introspective types. If we're not an identifiable, introspective type,
    // we don't need to perform additional validation for serialization â€”
    // just do enough to preallocate states and be done.
    var isIdentifiable = metadata is IIdentifiableTypeMetadata;

    var baseStateType = logicAttribute.StateType;
    var descendantStateTypes = Graph.GetDescendantSubtypes(baseStateType);

    // Only allocate list if we need to validate state types for serialization.
    var stateTypesNeedingAttention = isIdentifiable ?
      new HashSet<Type>(descendantStateTypes.Count + 1)
      : null;

    void cacheStateIfNeeded(Type type, IConcreteTypeMetadata metadata) {
      // Cache a pristine version of the state. Only done once per states
      // type (not instance). Used by the serialization system to determine
      // if it really needs to save a state.
      if (!ReferenceStates.ContainsKey(type)) {
        ReferenceStates.TryAdd(type, metadata.Factory());
      }
    }

    void discoverState(Type type) {
      if (isIdentifiable) {
        // Serializable states.
        var stateMetadata = Graph.GetMetadata(type);

        if (
          stateMetadata is IIntrospectiveTypeMetadata iMetadata &&
          iMetadata.Metatype.Attributes.ContainsKey(typeof(TestStateAttribute))
        ) {
          // Skip test states.
          return;
        }

        if (stateMetadata is IIdentifiableTypeMetadata idMetadata) {
          if (idMetadata is IConcreteTypeMetadata concreteMetadata) {
            cacheStateIfNeeded(type, concreteMetadata);

#if WITH_SERIALIZATION
            // We're a serializable states. States should only be saved if
            // they have diverged from the reference state.
            logic.SaveObject(
              type: type,
              factory: concreteMetadata.Factory,
              referenceValue: ReferenceStates[type]
            );
#endif

            // Force persisted state to be created and added to the blackboard.
            // Reasoning: do as much heap allocation as possible during setup
            // instead of during execution.
            logic.OverwriteObject(type, concreteMetadata.Factory());
          }
        }
        else if (stateMetadata is not IIntrospectiveTypeMetadata) {
          // State chart is serializable, but the state is not even an
          // introspective type. Add state to the list of states to mention
          // when we throw an error later.
          stateTypesNeedingAttention!.Add(type);
        }
        else if (stateMetadata is IConcreteTypeMetadata) {
          // Concrete introspective types on serializable statess MUST
          // be identifiable types.
          stateTypesNeedingAttention!.Add(type);
        }

        return;
      }

      // Non-serializable states.

      if (Graph.GetMetadata(type) is IConcreteTypeMetadata metadata) {
        cacheStateIfNeeded(type, metadata);
        // We're not a serializable states. Just add the state to the
        // blackboard the normal way.
        logic.OverwriteObject(type, metadata.Factory());
      }
    }

    discoverState(baseStateType);

    foreach (var stateType in descendantStateTypes) {
      discoverState(stateType);
    }

    if (!isIdentifiable) { return; }

    if (stateTypesNeedingAttention!.Count == 0) { return; }

    var statesNeedingAttention = string.Join(", ", stateTypesNeedingAttention);

    throw new StateChartException(
      $"Serializable StateChart `{type}` has states that are not " +
      $"serializable. Please ensure the following types have the " +
      $"[{nameof(MetaAttribute)}] and [{nameof(IdAttribute)}] attributes: " +
      $"{statesNeedingAttention}."
    );
  }
}
